/* ecg-monitor.c generated by valac 0.18.1, the Vala compiler
 * generated from ecg-monitor.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <ecg-parser.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define TYPE_ECG_MONITOR (ecg_monitor_get_type ())
#define ECG_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ECG_MONITOR, ECGMonitor))
#define ECG_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ECG_MONITOR, ECGMonitorClass))
#define IS_ECG_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ECG_MONITOR))
#define IS_ECG_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ECG_MONITOR))
#define ECG_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ECG_MONITOR, ECGMonitorClass))

typedef struct _ECGMonitor ECGMonitor;
typedef struct _ECGMonitorClass ECGMonitorClass;
typedef struct _ECGMonitorPrivate ECGMonitorPrivate;
#define _ecg_close0(var) ((var == NULL) ? NULL : (var = (ecg_close (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_region_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_region_destroy (var), NULL)))

struct _ECGMonitor {
	GtkDrawingArea parent_instance;
	ECGMonitorPrivate * priv;
	ECG* ecg;
	gint first_frame;
	gint first_cached_frame;
	gint last_cached_frame;
	gint start;
	gint end;
};

struct _ECGMonitorClass {
	GtkDrawingAreaClass parent_class;
};


static gpointer ecg_monitor_parent_class = NULL;

GType ecg_monitor_get_type (void) G_GNUC_CONST;
enum  {
	ECG_MONITOR_DUMMY_PROPERTY
};
void ecg_monitor_show_limb_leads (ECGMonitor* self);
static gboolean ecg_monitor_update (ECGMonitor* self);
void ecg_monitor_show_augment_limb_leads (ECGMonitor* self);
void ecg_monitor_show_chest_leads (ECGMonitor* self);
void ecg_monitor_load (ECGMonitor* self, const gchar* path);
ECGMonitor* ecg_monitor_new (void);
ECGMonitor* ecg_monitor_construct (GType object_type);
gint ecg_monitor_get_ecg_size (ECGMonitor* self);
gint ecg_monitor_get_ecg_shift (ECGMonitor* self);
void ecg_monitor_set_ecg_shift (ECGMonitor* self, gint shift);
static gboolean ecg_monitor_real_draw (GtkWidget* base, cairo_t* c);
static gboolean ecg_monitor_real_button_press_event (GtkWidget* base, GdkEventButton* event);
static gboolean ecg_monitor_real_button_release_event (GtkWidget* base, GdkEventButton* event);
static gboolean ecg_monitor_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event);
static void ecg_monitor_redraw_canvas (ECGMonitor* self);
static void ecg_monitor_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


void ecg_monitor_show_limb_leads (ECGMonitor* self) {
	g_return_if_fail (self != NULL);
	self->start = 0;
	self->end = 2;
	ecg_monitor_update (self);
}


void ecg_monitor_show_augment_limb_leads (ECGMonitor* self) {
	g_return_if_fail (self != NULL);
	self->start = 9;
	self->end = 12;
	ecg_monitor_update (self);
}


void ecg_monitor_show_chest_leads (ECGMonitor* self) {
	g_return_if_fail (self != NULL);
	self->start = 3;
	self->end = 8;
	ecg_monitor_update (self);
}


void ecg_monitor_load (ECGMonitor* self, const gchar* path) {
	const gchar* _tmp0_;
	ECG* _tmp1_ = NULL;
	ECG* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	self->start = 0;
	self->end = 2;
	_tmp0_ = path;
	_tmp1_ = ecg_open (_tmp0_);
	_ecg_close0 (self->ecg);
	self->ecg = _tmp1_;
	_tmp2_ = self->ecg;
	self->first_cached_frame = 0;
	_tmp3_ = self->first_cached_frame;
	self->last_cached_frame = 400;
	_tmp4_ = self->last_cached_frame;
	ecg_cache (_tmp2_, _tmp3_, _tmp4_);
	self->first_frame = 0;
	ecg_monitor_update (self);
}


ECGMonitor* ecg_monitor_construct (GType object_type) {
	ECGMonitor * self = NULL;
	self = (ECGMonitor*) g_object_new (object_type, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) ((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_POINTER_MOTION_MASK));
	gtk_widget_set_size_request ((GtkWidget*) self, 200, 225);
	return self;
}


ECGMonitor* ecg_monitor_new (void) {
	return ecg_monitor_construct (TYPE_ECG_MONITOR);
}


gint ecg_monitor_get_ecg_size (ECGMonitor* self) {
	gint result = 0;
	ECG* _tmp0_;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->ecg;
	_tmp1_ = ecg_get_frames_count (_tmp0_);
	result = _tmp1_;
	return result;
}


gint ecg_monitor_get_ecg_shift (ECGMonitor* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->first_frame;
	result = _tmp0_;
	return result;
}


void ecg_monitor_set_ecg_shift (ECGMonitor* self, gint shift) {
	gint _tmp0_;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_;
	gint _tmp3_;
	gboolean _tmp6_;
	g_return_if_fail (self != NULL);
	_tmp0_ = shift;
	self->first_frame = _tmp0_;
	_tmp2_ = self->first_frame;
	_tmp3_ = self->last_cached_frame;
	if ((_tmp2_ + 3000) > _tmp3_) {
		_tmp1_ = TRUE;
	} else {
		gint _tmp4_;
		gint _tmp5_;
		_tmp4_ = self->first_frame;
		_tmp5_ = self->first_cached_frame;
		_tmp1_ = _tmp4_ < _tmp5_;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		ECG* _tmp7_;
		gint _tmp8_ = 0;
		gint frames_count;
		gint _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		gint _tmp12_;
		gint _tmp13_;
		gint _tmp15_;
		gint _tmp16_;
		gint _tmp17_;
		ECG* _tmp19_;
		gint _tmp20_;
		gint _tmp21_;
		_tmp7_ = self->ecg;
		_tmp8_ = ecg_get_frames_count (_tmp7_);
		frames_count = _tmp8_;
		_tmp9_ = self->first_frame;
		self->first_cached_frame = _tmp9_ - 10000;
		_tmp10_ = self->first_frame;
		self->last_cached_frame = _tmp10_ + 10000;
		_tmp11_ = self->first_cached_frame;
		if (_tmp11_ < 0) {
			self->first_cached_frame = 0;
		}
		_tmp12_ = self->first_cached_frame;
		_tmp13_ = frames_count;
		if (_tmp12_ > _tmp13_) {
			gint _tmp14_;
			_tmp14_ = frames_count;
			self->first_cached_frame = _tmp14_;
		}
		_tmp15_ = self->last_cached_frame;
		if (_tmp15_ < 0) {
			self->last_cached_frame = 0;
		}
		_tmp16_ = self->last_cached_frame;
		_tmp17_ = frames_count;
		if (_tmp16_ > _tmp17_) {
			gint _tmp18_;
			_tmp18_ = frames_count;
			self->last_cached_frame = _tmp18_;
		}
		_tmp19_ = self->ecg;
		_tmp20_ = self->first_cached_frame;
		_tmp21_ = self->last_cached_frame;
		ecg_cache (_tmp19_, _tmp20_, _tmp21_);
	}
	ecg_monitor_update (self);
}


static gboolean ecg_monitor_real_draw (GtkWidget* base, cairo_t* c) {
	ECGMonitor * self;
	gboolean result = FALSE;
	ECG* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	gchar* _tmp10_;
	gchar* _tmp11_;
	gchar* _tmp12_;
	gchar* _tmp13_;
	gchar* _tmp14_;
	gchar* _tmp15_[14] = {0};
	gchar* channels_names[14];
	gfloat scale;
	gint _tmp16_ = 0;
	gint width;
	gint _tmp17_ = 0;
	gint height;
	cairo_t* _tmp18_;
	cairo_t* _tmp19_;
	gint _tmp20_;
	gint _tmp21_;
	cairo_t* _tmp22_;
	cairo_t* _tmp23_;
	gdouble magnitude_scale;
	cairo_t* _tmp28_;
	cairo_t* _tmp39_;
	cairo_t* _tmp93_;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (c != NULL, FALSE);
	_tmp0_ = self->ecg;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = g_strdup ("I");
	_tmp2_ = g_strdup ("II");
	_tmp3_ = g_strdup ("III");
	_tmp4_ = g_strdup ("V1");
	_tmp5_ = g_strdup ("V2");
	_tmp6_ = g_strdup ("V3");
	_tmp7_ = g_strdup ("V4");
	_tmp8_ = g_strdup ("V5");
	_tmp9_ = g_strdup ("V6");
	_tmp10_ = g_strdup ("aVR");
	_tmp11_ = g_strdup ("aVL");
	_tmp12_ = g_strdup ("aVF");
	_tmp13_ = g_strdup ("Unknown Channel");
	_tmp14_ = g_strdup ("0");
	_tmp15_[0] = _tmp1_;
	_tmp15_[1] = _tmp2_;
	_tmp15_[2] = _tmp3_;
	_tmp15_[3] = _tmp4_;
	_tmp15_[4] = _tmp5_;
	_tmp15_[5] = _tmp6_;
	_tmp15_[6] = _tmp7_;
	_tmp15_[7] = _tmp8_;
	_tmp15_[8] = _tmp9_;
	_tmp15_[9] = _tmp10_;
	_tmp15_[10] = _tmp11_;
	_tmp15_[11] = _tmp12_;
	_tmp15_[12] = _tmp13_;
	_tmp15_[13] = _tmp14_;
	memcpy (channels_names, _tmp15_, 14 * sizeof (gchar*));
	scale = 1.0f;
	_tmp16_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
	width = _tmp16_;
	_tmp17_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	height = _tmp17_;
	_tmp18_ = c;
	cairo_set_source_rgb (_tmp18_, 1.0, 1.0, 1.0);
	_tmp19_ = c;
	_tmp20_ = width;
	_tmp21_ = height;
	cairo_rectangle (_tmp19_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp20_, (gdouble) _tmp21_);
	_tmp22_ = c;
	cairo_fill (_tmp22_);
	_tmp23_ = c;
	cairo_set_source_rgb (_tmp23_, 0.0, 0.0, 0.0);
	magnitude_scale = (gdouble) 50.0f;
	if (FALSE) {
		cairo_t* _tmp24_;
		cairo_t* _tmp25_;
		_tmp24_ = c;
		cairo_move_to (_tmp24_, 40.0, 40.0);
		_tmp25_ = c;
		cairo_show_text (_tmp25_, "250 μV ✕ 100 ms");
		magnitude_scale = (gdouble) 100.0f;
	} else {
		cairo_t* _tmp26_;
		cairo_t* _tmp27_;
		_tmp26_ = c;
		cairo_move_to (_tmp26_, 40.0, 40.0);
		_tmp27_ = c;
		cairo_show_text (_tmp27_, "0.5 mV ✕ 100 ms");
	}
	_tmp28_ = c;
	cairo_set_line_width (_tmp28_, 0.25);
	{
		gdouble x;
		x = 0.5;
		{
			gboolean _tmp29_;
			_tmp29_ = TRUE;
			while (TRUE) {
				gboolean _tmp30_;
				gdouble _tmp32_;
				gint _tmp33_;
				cairo_t* _tmp34_;
				gdouble _tmp35_;
				cairo_t* _tmp36_;
				gdouble _tmp37_;
				gint _tmp38_;
				_tmp30_ = _tmp29_;
				if (!_tmp30_) {
					gdouble _tmp31_;
					_tmp31_ = x;
					x = _tmp31_ + 20.0;
				}
				_tmp29_ = FALSE;
				_tmp32_ = x;
				_tmp33_ = width;
				if (!(_tmp32_ < ((gdouble) _tmp33_))) {
					break;
				}
				_tmp34_ = c;
				_tmp35_ = x;
				cairo_move_to (_tmp34_, _tmp35_, (gdouble) 0);
				_tmp36_ = c;
				_tmp37_ = x;
				_tmp38_ = height;
				cairo_line_to (_tmp36_, _tmp37_, (gdouble) _tmp38_);
			}
		}
	}
	_tmp39_ = c;
	cairo_stroke (_tmp39_);
	{
		gint _tmp40_;
		gint channel;
		_tmp40_ = self->start;
		channel = _tmp40_;
		{
			gboolean _tmp41_;
			_tmp41_ = TRUE;
			while (TRUE) {
				gboolean _tmp42_;
				gint _tmp44_;
				gint _tmp45_;
				gint _tmp46_;
				gint _tmp47_;
				gdouble _tmp48_;
				gint _tmp49_;
				gint _tmp50_;
				gint _tmp51_;
				gdouble _tmp52_;
				gdouble y;
				cairo_t* _tmp53_;
				cairo_t* _tmp65_;
				cairo_t* _tmp66_;
				cairo_t* _tmp67_;
				gdouble _tmp68_;
				cairo_t* _tmp69_;
				gint _tmp70_;
				const gchar* _tmp71_;
				cairo_t* _tmp72_;
				gdouble _tmp73_;
				cairo_t* _tmp74_;
				gdouble _tmp75_;
				cairo_t* _tmp92_;
				_tmp42_ = _tmp41_;
				if (!_tmp42_) {
					gint _tmp43_;
					_tmp43_ = channel;
					channel = _tmp43_ + 1;
				}
				_tmp41_ = FALSE;
				_tmp44_ = channel;
				_tmp45_ = self->end;
				if (!(_tmp44_ <= _tmp45_)) {
					break;
				}
				_tmp46_ = channel;
				_tmp47_ = self->start;
				_tmp48_ = magnitude_scale;
				_tmp49_ = height;
				_tmp50_ = self->end;
				_tmp51_ = self->start;
				_tmp52_ = magnitude_scale;
				y = ((((_tmp46_ + 1) - _tmp47_) * _tmp48_) * 2) + ((_tmp49_ - ((((_tmp50_ - _tmp51_) + 2) * _tmp52_) * 2)) * 0.5);
				_tmp53_ = c;
				cairo_set_line_width (_tmp53_, 0.25);
				{
					gint k;
					k = -2;
					{
						gboolean _tmp54_;
						_tmp54_ = TRUE;
						while (TRUE) {
							gboolean _tmp55_;
							gint _tmp57_;
							cairo_t* _tmp58_;
							gdouble _tmp59_;
							gint _tmp60_;
							cairo_t* _tmp61_;
							gint _tmp62_;
							gdouble _tmp63_;
							gint _tmp64_;
							_tmp55_ = _tmp54_;
							if (!_tmp55_) {
								gint _tmp56_;
								_tmp56_ = k;
								k = _tmp56_ + 1;
							}
							_tmp54_ = FALSE;
							_tmp57_ = k;
							if (!(_tmp57_ <= 2)) {
								break;
							}
							_tmp58_ = c;
							_tmp59_ = y;
							_tmp60_ = k;
							cairo_move_to (_tmp58_, 0.0, _tmp59_ + (_tmp60_ * 20.0));
							_tmp61_ = c;
							_tmp62_ = width;
							_tmp63_ = y;
							_tmp64_ = k;
							cairo_line_to (_tmp61_, (gdouble) _tmp62_, _tmp63_ + (_tmp64_ * 20.0));
						}
					}
				}
				_tmp65_ = c;
				cairo_stroke (_tmp65_);
				_tmp66_ = c;
				cairo_set_line_width (_tmp66_, 1.0);
				_tmp67_ = c;
				_tmp68_ = y;
				cairo_move_to (_tmp67_, 40.0, _tmp68_ + 40.0);
				_tmp69_ = c;
				_tmp70_ = channel;
				_tmp71_ = channels_names[_tmp70_];
				cairo_show_text (_tmp69_, _tmp71_);
				_tmp72_ = c;
				_tmp73_ = y;
				cairo_move_to (_tmp72_, 200.0, _tmp73_ + 40.0);
				_tmp74_ = c;
				_tmp75_ = y;
				cairo_move_to (_tmp74_, (gdouble) 0, _tmp75_);
				{
					gint i;
					i = 0;
					{
						gboolean _tmp76_;
						_tmp76_ = TRUE;
						while (TRUE) {
							gboolean _tmp77_;
							gint _tmp79_;
							gint _tmp80_;
							gfloat _tmp81_;
							cairo_t* _tmp82_;
							gint _tmp83_;
							gfloat _tmp84_;
							gdouble _tmp85_;
							ECG* _tmp86_;
							gint _tmp87_;
							gint _tmp88_;
							gint _tmp89_;
							gfloat _tmp90_ = 0.0F;
							gdouble _tmp91_;
							_tmp77_ = _tmp76_;
							if (!_tmp77_) {
								gint _tmp78_;
								_tmp78_ = i;
								i = _tmp78_ + 1;
							}
							_tmp76_ = FALSE;
							_tmp79_ = i;
							_tmp80_ = width;
							_tmp81_ = scale;
							if (!(_tmp79_ < ((gint) ((_tmp80_ * 2.0) / _tmp81_)))) {
								break;
							}
							_tmp82_ = c;
							_tmp83_ = i;
							_tmp84_ = scale;
							_tmp85_ = y;
							_tmp86_ = self->ecg;
							_tmp87_ = channel;
							_tmp88_ = i;
							_tmp89_ = self->first_frame;
							_tmp90_ = ecg_get_magnitude (_tmp86_, _tmp87_, _tmp88_ + _tmp89_);
							_tmp91_ = magnitude_scale;
							cairo_line_to (_tmp82_, (_tmp83_ * _tmp84_) * 0.5, _tmp85_ - (_tmp90_ * _tmp91_));
						}
					}
				}
				_tmp92_ = c;
				cairo_stroke (_tmp92_);
			}
		}
	}
	_tmp93_ = c;
	cairo_stroke (_tmp93_);
	result = TRUE;
	_vala_array_destroy (channels_names, 14, (GDestroyNotify) g_free);
	return result;
}


static gboolean ecg_monitor_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	ECGMonitor * self;
	gboolean result = FALSE;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}


static gboolean ecg_monitor_real_button_release_event (GtkWidget* base, GdkEventButton* event) {
	ECGMonitor * self;
	gboolean result = FALSE;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}


static gboolean ecg_monitor_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event) {
	ECGMonitor * self;
	gboolean result = FALSE;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void ecg_monitor_redraw_canvas (ECGMonitor* self) {
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_;
	GdkWindow* window;
	GdkWindow* _tmp2_;
	GdkWindow* _tmp3_;
	cairo_region_t* _tmp4_ = NULL;
	cairo_region_t* region;
	GdkWindow* _tmp5_;
	cairo_region_t* _tmp6_;
	GdkWindow* _tmp7_;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	window = _tmp1_;
	_tmp2_ = window;
	if (_tmp2_ == NULL) {
		_g_object_unref0 (window);
		return;
	}
	_tmp3_ = window;
	_tmp4_ = gdk_window_get_clip_region (_tmp3_);
	region = _tmp4_;
	_tmp5_ = window;
	_tmp6_ = region;
	gdk_window_invalidate_region (_tmp5_, _tmp6_, TRUE);
	_tmp7_ = window;
	gdk_window_process_updates (_tmp7_, TRUE);
	_cairo_region_destroy0 (region);
	_g_object_unref0 (window);
}


static gboolean ecg_monitor_update (ECGMonitor* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	ecg_monitor_redraw_canvas (self);
	result = TRUE;
	return result;
}


static void ecg_monitor_class_init (ECGMonitorClass * klass) {
	ecg_monitor_parent_class = g_type_class_peek_parent (klass);
	GTK_WIDGET_CLASS (klass)->draw = ecg_monitor_real_draw;
	GTK_WIDGET_CLASS (klass)->button_press_event = ecg_monitor_real_button_press_event;
	GTK_WIDGET_CLASS (klass)->button_release_event = ecg_monitor_real_button_release_event;
	GTK_WIDGET_CLASS (klass)->motion_notify_event = ecg_monitor_real_motion_notify_event;
	G_OBJECT_CLASS (klass)->finalize = ecg_monitor_finalize;
}


static void ecg_monitor_instance_init (ECGMonitor * self) {
	self->ecg = NULL;
	self->first_frame = 0;
	self->first_cached_frame = 0;
	self->last_cached_frame = 0;
	self->start = 0;
	self->end = 11;
}


static void ecg_monitor_finalize (GObject* obj) {
	ECGMonitor * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ECG_MONITOR, ECGMonitor);
	_ecg_close0 (self->ecg);
	G_OBJECT_CLASS (ecg_monitor_parent_class)->finalize (obj);
}


GType ecg_monitor_get_type (void) {
	static volatile gsize ecg_monitor_type_id__volatile = 0;
	if (g_once_init_enter (&ecg_monitor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ECGMonitorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ecg_monitor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ECGMonitor), 0, (GInstanceInitFunc) ecg_monitor_instance_init, NULL };
		GType ecg_monitor_type_id;
		ecg_monitor_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "ECGMonitor", &g_define_type_info, 0);
		g_once_init_leave (&ecg_monitor_type_id__volatile, ecg_monitor_type_id);
	}
	return ecg_monitor_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



