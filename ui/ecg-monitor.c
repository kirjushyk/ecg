/* ecg-monitor.c generated by valac 0.21.1, the Vala compiler
 * generated from ecg-monitor.vala, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <ecg-parser.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <cairo.h>
#include <float.h>
#include <math.h>


#define TYPE_ECG_MONITOR (ecg_monitor_get_type ())
#define ECG_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_ECG_MONITOR, ECGMonitor))
#define ECG_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_ECG_MONITOR, ECGMonitorClass))
#define IS_ECG_MONITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_ECG_MONITOR))
#define IS_ECG_MONITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_ECG_MONITOR))
#define ECG_MONITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_ECG_MONITOR, ECGMonitorClass))

typedef struct _ECGMonitor ECGMonitor;
typedef struct _ECGMonitorClass ECGMonitorClass;
typedef struct _ECGMonitorPrivate ECGMonitorPrivate;
#define _ecg_close0(var) ((var == NULL) ? NULL : (var = (ecg_close (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _cairo_region_destroy0(var) ((var == NULL) ? NULL : (var = (cairo_region_destroy (var), NULL)))

struct _ECGMonitor {
	GtkDrawingArea parent_instance;
	ECGMonitorPrivate * priv;
	ECG* ecg;
	gint first_frame;
	gint first_cached_frame;
	gint last_cached_frame;
	gint start;
	gint end;
};

struct _ECGMonitorClass {
	GtkDrawingAreaClass parent_class;
};


static gpointer ecg_monitor_parent_class = NULL;

GType ecg_monitor_get_type (void) G_GNUC_CONST;
enum  {
	ECG_MONITOR_DUMMY_PROPERTY
};
void ecg_monitor_show_limb_leads (ECGMonitor* self);
static gboolean ecg_monitor_update (ECGMonitor* self);
void ecg_monitor_show_augment_limb_leads (ECGMonitor* self);
void ecg_monitor_show_chest_leads (ECGMonitor* self);
void ecg_monitor_load (ECGMonitor* self, const gchar* path);
ECGMonitor* ecg_monitor_new (void);
ECGMonitor* ecg_monitor_construct (GType object_type);
gint ecg_monitor_get_ecg_size (ECGMonitor* self);
gint ecg_monitor_get_ecg_shift (ECGMonitor* self);
void ecg_monitor_set_ecg_shift (ECGMonitor* self, gint shift);
static gboolean ecg_monitor_real_draw (GtkWidget* base, cairo_t* c);
static gboolean ecg_monitor_real_button_press_event (GtkWidget* base, GdkEventButton* event);
static gboolean ecg_monitor_real_button_release_event (GtkWidget* base, GdkEventButton* event);
static gboolean ecg_monitor_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event);
static void ecg_monitor_redraw_canvas (ECGMonitor* self);
static void ecg_monitor_finalize (GObject* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


void ecg_monitor_show_limb_leads (ECGMonitor* self) {
	g_return_if_fail (self != NULL);
	self->start = 0;
	self->end = 2;
	ecg_monitor_update (self);
}


void ecg_monitor_show_augment_limb_leads (ECGMonitor* self) {
	g_return_if_fail (self != NULL);
	self->start = 9;
	self->end = 12;
	ecg_monitor_update (self);
}


void ecg_monitor_show_chest_leads (ECGMonitor* self) {
	g_return_if_fail (self != NULL);
	self->start = 3;
	self->end = 8;
	ecg_monitor_update (self);
}


void ecg_monitor_load (ECGMonitor* self, const gchar* path) {
	const gchar* _tmp0_ = NULL;
	ECG* _tmp1_ = NULL;
	ECG* _tmp2_ = NULL;
	gint _tmp3_ = 0;
	gint _tmp4_ = 0;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	self->start = 0;
	self->end = 2;
	_tmp0_ = path;
	_tmp1_ = ecg_open (_tmp0_);
	_ecg_close0 (self->ecg);
	self->ecg = _tmp1_;
	_tmp2_ = self->ecg;
	self->first_cached_frame = 0;
	_tmp3_ = self->first_cached_frame;
	self->last_cached_frame = 400;
	_tmp4_ = self->last_cached_frame;
	ecg_cache (_tmp2_, _tmp3_, _tmp4_);
	self->first_frame = 0;
	ecg_monitor_update (self);
}


ECGMonitor* ecg_monitor_construct (GType object_type) {
	ECGMonitor * self = NULL;
	self = (ECGMonitor*) g_object_new (object_type, NULL);
	gtk_widget_add_events ((GtkWidget*) self, (gint) ((GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK) | GDK_POINTER_MOTION_MASK));
	gtk_widget_set_size_request ((GtkWidget*) self, 200, 225);
	return self;
}


ECGMonitor* ecg_monitor_new (void) {
	return ecg_monitor_construct (TYPE_ECG_MONITOR);
}


gint ecg_monitor_get_ecg_size (ECGMonitor* self) {
	gint result = 0;
	ECG* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->ecg;
	_tmp1_ = ecg_get_frames_count (_tmp0_);
	result = _tmp1_;
	return result;
}


gint ecg_monitor_get_ecg_shift (ECGMonitor* self) {
	gint result = 0;
	gint _tmp0_ = 0;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->first_frame;
	result = _tmp0_;
	return result;
}


void ecg_monitor_set_ecg_shift (ECGMonitor* self, gint shift) {
	gint _tmp0_ = 0;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_ = 0;
	gint _tmp3_ = 0;
	gboolean _tmp6_ = FALSE;
	g_return_if_fail (self != NULL);
	_tmp0_ = shift;
	self->first_frame = _tmp0_;
	_tmp2_ = self->first_frame;
	_tmp3_ = self->last_cached_frame;
	if ((_tmp2_ + 3000) > _tmp3_) {
		_tmp1_ = TRUE;
	} else {
		gint _tmp4_ = 0;
		gint _tmp5_ = 0;
		_tmp4_ = self->first_frame;
		_tmp5_ = self->first_cached_frame;
		_tmp1_ = _tmp4_ < _tmp5_;
	}
	_tmp6_ = _tmp1_;
	if (_tmp6_) {
		gint frames_count = 0;
		ECG* _tmp7_ = NULL;
		gint _tmp8_ = 0;
		gint _tmp9_ = 0;
		gint _tmp10_ = 0;
		gint _tmp11_ = 0;
		gint _tmp12_ = 0;
		gint _tmp13_ = 0;
		gint _tmp15_ = 0;
		gint _tmp16_ = 0;
		gint _tmp17_ = 0;
		ECG* _tmp19_ = NULL;
		gint _tmp20_ = 0;
		gint _tmp21_ = 0;
		_tmp7_ = self->ecg;
		_tmp8_ = ecg_get_frames_count (_tmp7_);
		frames_count = _tmp8_;
		_tmp9_ = self->first_frame;
		self->first_cached_frame = _tmp9_ - 10000;
		_tmp10_ = self->first_frame;
		self->last_cached_frame = _tmp10_ + 10000;
		_tmp11_ = self->first_cached_frame;
		if (_tmp11_ < 0) {
			self->first_cached_frame = 0;
		}
		_tmp12_ = self->first_cached_frame;
		_tmp13_ = frames_count;
		if (_tmp12_ > _tmp13_) {
			gint _tmp14_ = 0;
			_tmp14_ = frames_count;
			self->first_cached_frame = _tmp14_;
		}
		_tmp15_ = self->last_cached_frame;
		if (_tmp15_ < 0) {
			self->last_cached_frame = 0;
		}
		_tmp16_ = self->last_cached_frame;
		_tmp17_ = frames_count;
		if (_tmp16_ > _tmp17_) {
			gint _tmp18_ = 0;
			_tmp18_ = frames_count;
			self->last_cached_frame = _tmp18_;
		}
		_tmp19_ = self->ecg;
		_tmp20_ = self->first_cached_frame;
		_tmp21_ = self->last_cached_frame;
		ecg_cache (_tmp19_, _tmp20_, _tmp21_);
	}
	ecg_monitor_update (self);
}


static gboolean ecg_monitor_real_draw (GtkWidget* base, cairo_t* c) {
	ECGMonitor * self;
	gboolean result = FALSE;
	ECG* _tmp0_ = NULL;
	gchar* channels_names[14] = {0};
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_ = NULL;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_ = NULL;
	gchar* _tmp8_ = NULL;
	gchar* _tmp9_ = NULL;
	gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	gchar* _tmp12_ = NULL;
	gchar* _tmp13_ = NULL;
	gchar* _tmp14_ = NULL;
	gchar* _tmp15_[14] = {0};
	gfloat scale = 0.0F;
	gint width = 0;
	gint _tmp16_ = 0;
	gint height = 0;
	gint _tmp17_ = 0;
	cairo_t* _tmp18_ = NULL;
	cairo_t* _tmp19_ = NULL;
	gint _tmp20_ = 0;
	gint _tmp21_ = 0;
	cairo_t* _tmp22_ = NULL;
	cairo_t* _tmp23_ = NULL;
	gdouble magnitude_scale = 0.0;
	cairo_t* _tmp26_ = NULL;
	cairo_t* _tmp37_ = NULL;
	cairo_t* _tmp91_ = NULL;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (c != NULL, FALSE);
	_tmp0_ = self->ecg;
	if (_tmp0_ == NULL) {
		result = TRUE;
		return result;
	}
	_tmp1_ = g_strdup ("I");
	_tmp2_ = g_strdup ("II");
	_tmp3_ = g_strdup ("III");
	_tmp4_ = g_strdup ("V1");
	_tmp5_ = g_strdup ("V2");
	_tmp6_ = g_strdup ("V3");
	_tmp7_ = g_strdup ("V4");
	_tmp8_ = g_strdup ("V5");
	_tmp9_ = g_strdup ("V6");
	_tmp10_ = g_strdup ("aVR");
	_tmp11_ = g_strdup ("aVL");
	_tmp12_ = g_strdup ("aVF");
	_tmp13_ = g_strdup ("Unknown Channel");
	_tmp14_ = g_strdup ("0");
	_tmp15_[0] = _tmp1_;
	_tmp15_[1] = _tmp2_;
	_tmp15_[2] = _tmp3_;
	_tmp15_[3] = _tmp4_;
	_tmp15_[4] = _tmp5_;
	_tmp15_[5] = _tmp6_;
	_tmp15_[6] = _tmp7_;
	_tmp15_[7] = _tmp8_;
	_tmp15_[8] = _tmp9_;
	_tmp15_[9] = _tmp10_;
	_tmp15_[10] = _tmp11_;
	_tmp15_[11] = _tmp12_;
	_tmp15_[12] = _tmp13_;
	_tmp15_[13] = _tmp14_;
	memcpy (channels_names, _tmp15_, 14 * sizeof (gchar*));
	scale = 1.0f;
	_tmp16_ = gtk_widget_get_allocated_width ((GtkWidget*) self);
	width = _tmp16_;
	_tmp17_ = gtk_widget_get_allocated_height ((GtkWidget*) self);
	height = _tmp17_;
	_tmp18_ = c;
	cairo_set_source_rgb (_tmp18_, 1.0, 1.0, 1.0);
	_tmp19_ = c;
	_tmp20_ = width;
	_tmp21_ = height;
	cairo_rectangle (_tmp19_, (gdouble) 0, (gdouble) 0, (gdouble) _tmp20_, (gdouble) _tmp21_);
	_tmp22_ = c;
	cairo_fill (_tmp22_);
	_tmp23_ = c;
	cairo_set_source_rgb (_tmp23_, 0.0, 0.0, 0.0);
	magnitude_scale = (gdouble) 50.0f;
	{
		cairo_t* _tmp24_ = NULL;
		cairo_t* _tmp25_ = NULL;
		_tmp24_ = c;
		cairo_move_to (_tmp24_, 40.0, 40.0);
		_tmp25_ = c;
		cairo_show_text (_tmp25_, "0.5 mV âœ• 100 ms");
	}
	_tmp26_ = c;
	cairo_set_line_width (_tmp26_, 0.25);
	{
		gdouble x = 0.0;
		x = 0.5;
		{
			gboolean _tmp27_ = FALSE;
			_tmp27_ = TRUE;
			while (TRUE) {
				gboolean _tmp28_ = FALSE;
				gdouble _tmp30_ = 0.0;
				gint _tmp31_ = 0;
				cairo_t* _tmp32_ = NULL;
				gdouble _tmp33_ = 0.0;
				cairo_t* _tmp34_ = NULL;
				gdouble _tmp35_ = 0.0;
				gint _tmp36_ = 0;
				_tmp28_ = _tmp27_;
				if (!_tmp28_) {
					gdouble _tmp29_ = 0.0;
					_tmp29_ = x;
					x = _tmp29_ + 20.0;
				}
				_tmp27_ = FALSE;
				_tmp30_ = x;
				_tmp31_ = width;
				if (!(_tmp30_ < ((gdouble) _tmp31_))) {
					break;
				}
				_tmp32_ = c;
				_tmp33_ = x;
				cairo_move_to (_tmp32_, _tmp33_, (gdouble) 0);
				_tmp34_ = c;
				_tmp35_ = x;
				_tmp36_ = height;
				cairo_line_to (_tmp34_, _tmp35_, (gdouble) _tmp36_);
			}
		}
	}
	_tmp37_ = c;
	cairo_stroke (_tmp37_);
	{
		gint channel = 0;
		gint _tmp38_ = 0;
		_tmp38_ = self->start;
		channel = _tmp38_;
		{
			gboolean _tmp39_ = FALSE;
			_tmp39_ = TRUE;
			while (TRUE) {
				gboolean _tmp40_ = FALSE;
				gint _tmp42_ = 0;
				gint _tmp43_ = 0;
				gdouble y = 0.0;
				gint _tmp44_ = 0;
				gint _tmp45_ = 0;
				gdouble _tmp46_ = 0.0;
				gint _tmp47_ = 0;
				gint _tmp48_ = 0;
				gint _tmp49_ = 0;
				gdouble _tmp50_ = 0.0;
				cairo_t* _tmp51_ = NULL;
				cairo_t* _tmp63_ = NULL;
				cairo_t* _tmp64_ = NULL;
				cairo_t* _tmp65_ = NULL;
				gdouble _tmp66_ = 0.0;
				cairo_t* _tmp67_ = NULL;
				gint _tmp68_ = 0;
				const gchar* _tmp69_ = NULL;
				cairo_t* _tmp70_ = NULL;
				gdouble _tmp71_ = 0.0;
				cairo_t* _tmp72_ = NULL;
				gdouble _tmp73_ = 0.0;
				cairo_t* _tmp90_ = NULL;
				_tmp40_ = _tmp39_;
				if (!_tmp40_) {
					gint _tmp41_ = 0;
					_tmp41_ = channel;
					channel = _tmp41_ + 1;
				}
				_tmp39_ = FALSE;
				_tmp42_ = channel;
				_tmp43_ = self->end;
				if (!(_tmp42_ <= _tmp43_)) {
					break;
				}
				_tmp44_ = channel;
				_tmp45_ = self->start;
				_tmp46_ = magnitude_scale;
				_tmp47_ = height;
				_tmp48_ = self->end;
				_tmp49_ = self->start;
				_tmp50_ = magnitude_scale;
				y = ((((_tmp44_ + 1) - _tmp45_) * _tmp46_) * 2) + ((_tmp47_ - ((((_tmp48_ - _tmp49_) + 2) * _tmp50_) * 2)) * 0.5);
				_tmp51_ = c;
				cairo_set_line_width (_tmp51_, 0.25);
				{
					gint k = 0;
					k = -2;
					{
						gboolean _tmp52_ = FALSE;
						_tmp52_ = TRUE;
						while (TRUE) {
							gboolean _tmp53_ = FALSE;
							gint _tmp55_ = 0;
							cairo_t* _tmp56_ = NULL;
							gdouble _tmp57_ = 0.0;
							gint _tmp58_ = 0;
							cairo_t* _tmp59_ = NULL;
							gint _tmp60_ = 0;
							gdouble _tmp61_ = 0.0;
							gint _tmp62_ = 0;
							_tmp53_ = _tmp52_;
							if (!_tmp53_) {
								gint _tmp54_ = 0;
								_tmp54_ = k;
								k = _tmp54_ + 1;
							}
							_tmp52_ = FALSE;
							_tmp55_ = k;
							if (!(_tmp55_ <= 2)) {
								break;
							}
							_tmp56_ = c;
							_tmp57_ = y;
							_tmp58_ = k;
							cairo_move_to (_tmp56_, 0.0, _tmp57_ + (_tmp58_ * 20.0));
							_tmp59_ = c;
							_tmp60_ = width;
							_tmp61_ = y;
							_tmp62_ = k;
							cairo_line_to (_tmp59_, (gdouble) _tmp60_, _tmp61_ + (_tmp62_ * 20.0));
						}
					}
				}
				_tmp63_ = c;
				cairo_stroke (_tmp63_);
				_tmp64_ = c;
				cairo_set_line_width (_tmp64_, 1.0);
				_tmp65_ = c;
				_tmp66_ = y;
				cairo_move_to (_tmp65_, 40.0, _tmp66_ + 40.0);
				_tmp67_ = c;
				_tmp68_ = channel;
				_tmp69_ = channels_names[_tmp68_];
				cairo_show_text (_tmp67_, _tmp69_);
				_tmp70_ = c;
				_tmp71_ = y;
				cairo_move_to (_tmp70_, 200.0, _tmp71_ + 40.0);
				_tmp72_ = c;
				_tmp73_ = y;
				cairo_move_to (_tmp72_, (gdouble) 0, _tmp73_);
				{
					gint i = 0;
					i = 0;
					{
						gboolean _tmp74_ = FALSE;
						_tmp74_ = TRUE;
						while (TRUE) {
							gboolean _tmp75_ = FALSE;
							gint _tmp77_ = 0;
							gint _tmp78_ = 0;
							gfloat _tmp79_ = 0.0F;
							cairo_t* _tmp80_ = NULL;
							gint _tmp81_ = 0;
							gfloat _tmp82_ = 0.0F;
							gdouble _tmp83_ = 0.0;
							ECG* _tmp84_ = NULL;
							gint _tmp85_ = 0;
							gint _tmp86_ = 0;
							gint _tmp87_ = 0;
							gfloat _tmp88_ = 0.0F;
							gdouble _tmp89_ = 0.0;
							_tmp75_ = _tmp74_;
							if (!_tmp75_) {
								gint _tmp76_ = 0;
								_tmp76_ = i;
								i = _tmp76_ + 1;
							}
							_tmp74_ = FALSE;
							_tmp77_ = i;
							_tmp78_ = width;
							_tmp79_ = scale;
							if (!(_tmp77_ < ((gint) ((_tmp78_ * 2.0) / _tmp79_)))) {
								break;
							}
							_tmp80_ = c;
							_tmp81_ = i;
							_tmp82_ = scale;
							_tmp83_ = y;
							_tmp84_ = self->ecg;
							_tmp85_ = channel;
							_tmp86_ = i;
							_tmp87_ = self->first_frame;
							_tmp88_ = ecg_get_magnitude (_tmp84_, _tmp85_, _tmp86_ + _tmp87_);
							_tmp89_ = magnitude_scale;
							cairo_line_to (_tmp80_, (_tmp81_ * _tmp82_) * 0.5, _tmp83_ - (_tmp88_ * _tmp89_));
						}
					}
				}
				_tmp90_ = c;
				cairo_stroke (_tmp90_);
			}
		}
	}
	_tmp91_ = c;
	cairo_stroke (_tmp91_);
	result = TRUE;
	_vala_array_destroy (channels_names, 14, (GDestroyNotify) g_free);
	return result;
}


static gboolean ecg_monitor_real_button_press_event (GtkWidget* base, GdkEventButton* event) {
	ECGMonitor * self;
	gboolean result = FALSE;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}


static gboolean ecg_monitor_real_button_release_event (GtkWidget* base, GdkEventButton* event) {
	ECGMonitor * self;
	gboolean result = FALSE;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}


static gboolean ecg_monitor_real_motion_notify_event (GtkWidget* base, GdkEventMotion* event) {
	ECGMonitor * self;
	gboolean result = FALSE;
	self = (ECGMonitor*) base;
	g_return_val_if_fail (event != NULL, FALSE);
	result = FALSE;
	return result;
}


static gpointer _g_object_ref0 (gpointer self) {
	return self ? g_object_ref (self) : NULL;
}


static void ecg_monitor_redraw_canvas (ECGMonitor* self) {
	GdkWindow* window = NULL;
	GdkWindow* _tmp0_ = NULL;
	GdkWindow* _tmp1_ = NULL;
	GdkWindow* _tmp2_ = NULL;
	cairo_region_t* region = NULL;
	GdkWindow* _tmp3_ = NULL;
	cairo_region_t* _tmp4_ = NULL;
	GdkWindow* _tmp5_ = NULL;
	cairo_region_t* _tmp6_ = NULL;
	GdkWindow* _tmp7_ = NULL;
	g_return_if_fail (self != NULL);
	_tmp0_ = gtk_widget_get_window ((GtkWidget*) self);
	_tmp1_ = _g_object_ref0 (_tmp0_);
	window = _tmp1_;
	_tmp2_ = window;
	if (_tmp2_ == NULL) {
		_g_object_unref0 (window);
		return;
	}
	_tmp3_ = window;
	_tmp4_ = gdk_window_get_clip_region (_tmp3_);
	region = _tmp4_;
	_tmp5_ = window;
	_tmp6_ = region;
	gdk_window_invalidate_region (_tmp5_, _tmp6_, TRUE);
	_tmp7_ = window;
	gdk_window_process_updates (_tmp7_, TRUE);
	_cairo_region_destroy0 (region);
	_g_object_unref0 (window);
}


static gboolean ecg_monitor_update (ECGMonitor* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	ecg_monitor_redraw_canvas (self);
	result = TRUE;
	return result;
}


static void ecg_monitor_class_init (ECGMonitorClass * klass) {
	ecg_monitor_parent_class = g_type_class_peek_parent (klass);
	GTK_WIDGET_CLASS (klass)->draw = ecg_monitor_real_draw;
	GTK_WIDGET_CLASS (klass)->button_press_event = ecg_monitor_real_button_press_event;
	GTK_WIDGET_CLASS (klass)->button_release_event = ecg_monitor_real_button_release_event;
	GTK_WIDGET_CLASS (klass)->motion_notify_event = ecg_monitor_real_motion_notify_event;
	G_OBJECT_CLASS (klass)->finalize = ecg_monitor_finalize;
}


static void ecg_monitor_instance_init (ECGMonitor * self) {
	self->ecg = NULL;
	self->first_frame = 0;
	self->first_cached_frame = 0;
	self->last_cached_frame = 0;
	self->start = 0;
	self->end = 11;
}


static void ecg_monitor_finalize (GObject* obj) {
	ECGMonitor * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_ECG_MONITOR, ECGMonitor);
	_ecg_close0 (self->ecg);
	G_OBJECT_CLASS (ecg_monitor_parent_class)->finalize (obj);
}


GType ecg_monitor_get_type (void) {
	static volatile gsize ecg_monitor_type_id__volatile = 0;
	if (g_once_init_enter (&ecg_monitor_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ECGMonitorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) ecg_monitor_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ECGMonitor), 0, (GInstanceInitFunc) ecg_monitor_instance_init, NULL };
		GType ecg_monitor_type_id;
		ecg_monitor_type_id = g_type_register_static (GTK_TYPE_DRAWING_AREA, "ECGMonitor", &g_define_type_info, 0);
		g_once_init_leave (&ecg_monitor_type_id__volatile, ecg_monitor_type_id);
	}
	return ecg_monitor_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}



